package stage3.engine.calc.implement;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.util.CollectionUtils;

import stage3.engine.calc.計算器;
import stage3.engine.parse.計算式;
import stage3.engine.statement.Statement;
import stage3.things.multiConditionCalc.CRUDer;

public class SumEvery計算器 implements 計算器 {

	@Override
	public Object 個別計算_根据計算項目List(List<String> paramList) {
		// TODO 自動生成されたメソッド・スタブ
		return null;
	}

	/**
	 * 1、初次取得（检索）
	 * 2、如果没有结果，且有时间条件时
	 * 3、就需要拆分时间，
	 * 4、根据拆分得到的子时间值、与原来的其他条件一起进行递归处理。
	 *    4.1、重置条件
	 *    4.2、递归调用
	 * 5、计算时间集合产物
	 * 6、返回时间集合产物
	 *
	 * 例，取得【2018年】成交笔数
	 *     如果2018年的成交笔数还没有计算好（初次取得）
	 *     那就继续向下计算：              （如果没有结果，且有时间条件时）
	 *     取得2018年的拆分结果：201801月-201812月（拆分时间）
	 *     取得【201801月】成交笔数（根据拆分得到的子时间值、与原来的其他条件一起进行递归处理。）
	 *     		(重置条件)
	 *     		(递归调用)
	 *     计算【2018年】成交笔数 = 【201801月】成交笔数，，，，【201812月】成交笔数的合计（计算时间集合产物）
	 *     返回【2018年】成交笔数（返回时间集合产物）
	 */


	@Override
	public Object 個別計算_根据計算項目List(Map 入力情報Map) {
		return null;
	}
	/**-----------------------------
	// 入力情報Map
	//      |------条件Map
	//		|			|------时间值/时间区间
	//		|			|------銘柄
	//		|------Every:价格
	//		|------Sum:成交量
	//
	//	Output
	//		|------

	// 処理開始

	// 根据条件信息，取得处理对象List
	//	|
	//	|------如果在【条件中有时间对象】，即用时间组件（取得时间对象值List），并取得目标结果 = 时间值List
	//		 	|
	//		 	|------如果其中有区间条件，目标结果 = List<目标值>
	//		 	|
	//		 	|------如果是单一结果, 目标结果 = <词条ID，数据IDList>
	//
	// 针对Every的对象词条
	//       |
	//       |------针对 条件的【目标结果】，取得对应的Every的值List  //如果是年=2018，就取2018的对应的值
	//		 |		|											//如果是2018-2020，就取{2018，2019，2020}
	//		 |		|											//然后再针对每个年分去计算
	//		 |		|
	//		 | 		|------如果，取到结果，就key=条件结果的每一个值(例，年=2018)，value=条件结果对应的Every值(Object)
	//		 |		|
	//		 | 		|------如果，没有取到，就要调用【挖掘模式(条件情报(时间值/时间区间，銘柄),条件结果的每一个值)】
	//		 |				|		// 例。2018年没有找到某只【銘柄】的成交价格，你就需要立即去计算。
	//		 | 				|       // 计算的目的：就是将你手下的价格与成交都绑在你的身上
	 * 		 | 				|       //     （这种特别的计算是不是需要程序来支持呢）
	 *       | 				|       //     （to成交价，from时间值）的程序
	 *       | 				|       //     （这个计算，需要定义CRUD文）
	 *       | 				|       //      (然后call THINGs DB的入口)
	 *       | 				|       //      例： NOSQL.取得指定値_根据入力字典and出力字典and入力数据
	 *       | 				|       //
	 *       | 				|       //
	 *       | 				|       //
	 *       | 				|       //
	//		 | 				|------设置条件情报     ：应该是下一层级的时间为目标 //需要调用下一层级然后分别取值
	//		 | 				|------设置Every情报：价格词条
	//		 | 				|------设置Sum情报     ：成交量词条
	//		 | 				|------挖掘结果 =【挖掘模式(条件情报(时间值/时间区间，銘柄),条件结果的每一个值)】
	//		 |
	//		 |
	//       |------针对Every的值List中的每一个值，取得其要对应的Sum对象的值
	//				|
	// 				|------如果【Sum对象的值】为空      // 例，某价格的成交量没有被计算出来。
	// 				|		|						应该还没有被计算出来，那就计算一下吧。
	//				|		|
	//				|		|------如果【条件中有时间对象】 // 例如
	//				|				|
	//				|				|------设置条件情报：Every的值对应的条件的【目标结果】和銘柄
	//				|				|------设置Every情报：价格词条
	//				|				|------设置Sum情报：成交量词条
	//				|				|------挖掘结果 =【挖掘模式(条件情报(时间值/时间区间，銘柄), Every的值(某一价格))】
	//				|				|
	//				|				|------如果【挖掘结果】为空
	//				|						|
	//				|						|------返回 Error【无可用数据】
	//				|
	//	     		|------在Output用Key=Every的值
	//	     		|
	//       		|------将Sum与既存值相加，存入Value中
	//	     		|
	//				|------更新Output
	//
	// 返回Output
	*/

	@Override
	public Object 個別計算_根据計算項目List(Map 個別計算Map, Map f臨時計算結果Map, 計算式 o計算式, Map<String, 計算式> 計算式Map) {
		/**
		 * 首先，你要计算Every
		 *       就是，你要找到2018年这支股票的每个成交价格
		 *
		 *       成交价
		 *			|-----G
	 	 *				  |-----股号
		 *						 |----时间
		 *	 						 	|-----成交价List
		 *
		 *       但是这样计算往往是找不到结果的。
		 *       	|-----原因在于没有直接的结果。
		 *
		 *       	你需要细化操作
		 *       		|------就是逐渐降低时间级别，看看有没有更下一层的精度上有没有相关的信息。
		 *
		 *       	直到你发现有信息可查。然后进行下一步计算。
		 *       		例，某天有100个成交价格。然后这一天所在的上一个时间单位（周），
		 *
		 *       	最后你需要向上汇总
		 *       		|-----就是将所有手下人的对应记录，都汇集到你这里
		 *
		 *       这样你就可以搞到Every的值了
		 *
		 * 下面你就要计算Sum了
		 * 		 就是，你要计算每个成交价所对应的成交量集合了。
		 *
		 * 		1 取得 时间ID
		 *		2 取得 股号ID
		 *		3 取得 价格ID
		 *		4 然后取成交量的IDList
		 *		5 最后分别累计就可以了。
		 */
		/**
		 * 入力情報Map
		 * 			|-----条件Map
		 * 			|		|-------Map1 = 項目,ID,目標,計算符号,値
		 * 			|		|-------Map2 = 項目,ID,目標,計算符号,値
		 * 			|-----条件関係
		 * 			|-----Every
		 * 			|-----Sum
		 */

		// 入力情報Map.put("目標", value);
		Map 検索用map = new HashMap();
		List<Map> 条件MapList = (List<Map>) 做成CRUD用条件MapList(個別計算Map, f臨時計算結果Map, o計算式, 計算式Map);

		 /*-----------------------------------------------------------
		 *        成交价
		 *			|-----G
	 	 *				  |-----股号
		 *						 |-----时间
		 *								|-----成交价List
		 -----------------------------------------------------------*/
		//MultiConditionCalc multiConditionCalc = new MultiConditionCalc("個別計算_根据計算項目List()");

		// 结果集
		List<Map> resultList = new ArrayList();

		/*------------------------計算_多条件関係------------------------------------
		{
		"操作":"検索",
		"目標":{
				"社員Bean":["番号","姓名","性別","生年月日","入社年月日","契約種類"]},
		"条件":[{"値":"2790001","FORMAT":"0","目標":"社員Bean","項目":"番号","ID":"0","計算符号":"等于"},
				{"値":"sss","FORMAT":"0","目標":"社員Bean","項目":"姓名","ID":"1","計算符号":"like"},
				{"値":"女","FORMAT":"0","目標":"社員Bean","項目":"性別","ID":"2","計算符号":"like"},
				{"値":"役員","FORMAT":"0","目標":"社員Bean","項目":"契約種類","ID":"3","計算符号":"等于"}],
		"条件関係":"0 and 1 and 2 and 3 "
		}
	 ------------------------------------------------------------------------------*/
			 /*-----------------------------------------------------------
			 *        成交量
			 *			|-----G
		 	 *				  |-----股号
			 *						 |-----时间
			 *								|-----成交价
			 *	 						 			|-----成交量List
			 -----------------------------------------------------------*/

			// 找到每个成交价(股号、时间)的成交量List
			検索用map.put("操作","検索");
			検索用map.put("条件",条件MapList);
			検索用map.put("目標", f臨時計算結果Map.get("Every"));

			//List<Object> 子ResultList = oCURDer.search(検索用map);

			// 整合这些分解的子時間計算結果List_To_主干上
			// resultList
			//		|-----Map<'成交量', 成交量集合>

			// 如何整合这些结果、需要查找方法。
			// 然后根据具体的情况、来具体执行。
			CRUDer oCRUDer = new CRUDer("SumEvery計算器");
			List<Map> 子SumResultList = oCRUDer.search(検索用map);

			// 把当前价格的成交量合计归纳到结果集中
			resultList.addAll(子SumResultList);


		return resultList;
	}

	private List<Map> 做成CRUD用条件MapList(Map 個別計算Map, Map f臨時計算結果Map, 計算式 o計算式, Map<String, 計算式> 計算式Map) {
		// 個別計算Map={0.7944323805312208=2018-12-13, 0.28641326332834016=SH600734}
		// f臨時計算結果Map={0.662058848662543=成交价, 0.1869273959630312=成交量, 0.28641326332834016=SH600734, 0.7944323805312208=2018-12-13, Every=成交价, Sum=成交量, 時間=2018-12-13, 股票代码=SH600734}
		//
		// 我要为CRUD准备【条件】信息
		// 就是说我不仅要知道有什么值，还要知道这个值是干什么的，
		// 每个计算式都记录着它的一些属性，例如，出力字典
		// 所以，毫无疑问，需要将【计算式】也带进来        2018-12-14

		List<Map> 条件MapList = new ArrayList();
		Statement statement = new Statement();

		// 取得本计算式的子计算式的实体
		List<計算式> 子計算式实体List = statement.取得子计算式的实体_by計算式_計算式Map(o計算式, 計算式Map);

		// 必须会有子计算式的，否则在计算式解析时就会被砍掉，参照：計算式.is計算式做成理論完成_計算計算式_計算器
		// 但以防万一，还是做个CHK吧
		if(CollectionUtils.isEmpty(子計算式实体List)) {
			return null;
		}

		int i=0; // 循环计数用的
		for(計算式 o子計算式 : 子計算式实体List) {

			if(o子計算式 == null) return null;
			//String 入力字典 = o子計算式.getNosql入力字典().getS入力字典();
			String 出力字典 = o子計算式.getNosql入力字典().getS出力字典();
			//String 入力項目 = o計算式.getNosql入力字典().getS入力項目();
			String 外部入力 = o子計算式.getNosql入力字典().getS外部入力();

			Map 条件Map = new HashMap();
			条件Map.put("値", 外部入力);
			// 这里应该是Every的对象，例，时间和股票代码都是为了取得其成交价
			条件Map.put("目標", f臨時計算結果Map.get("Every"));
			条件Map.put("項目", 出力字典);
			条件Map.put("計算符号", "等于"); // 参照：
			条件Map.put("ID", i);
			条件MapList.add(条件Map);
			i++;
		}

		/*		for(Map map : 条件Map) {
					map.put("項目", entry.getValue());
					map.put("ID", 0);
					map.put("計算符号", value);
				}
				Map 条件Map1 = new HashMap();
				Map 条件Map2 = new HashMap();

				条件Map1.put("値", value);
				条件Map1.put("目標", value);
				条件Map1.put("項目", value);
				条件Map1.put("計算符号", value);
				条件Map1.put("ID", 0);

				条件Map2.put("値", value);
				条件Map2.put("目標", value);
				条件Map2.put("項目", value);
				条件Map2.put("計算符号", value);
				条件Map2.put("ID", 1);

				List<Map> 条件MapList = new ArrayList();
				条件MapList.add(条件Map1);
				条件MapList.add(条件Map2);*/


		return 条件MapList;
	}



}
